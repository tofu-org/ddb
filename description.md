# 3 Рабочий проект системы "Винлаб"

## 3.1 Руководство пользователя

### 3.1.1 Назначение системы

Система "Винлаб" представляет собой распределенное программное обеспечение для автоматизации управления заказами алкогольной продукции в розничной сети магазинов. Система реализована на базе веб-технологий с использованием фреймворка Flask и реляционной СУБД PostgreSQL с встроенными механизмами репликации данных.

### 3.1.2 Требования к аппаратному и программному обеспечению

**Минимальные системные требования:**
- Процессор: 1 ГГц или выше (многоядерный рекомендуется)
- Оперативная память: 2 ГБ (4 ГБ рекомендуется)
- Свободное дисковое пространство: 2 ГБ
- Сетевое подключение: 10 Мбит/с

**Программное обеспечение:**
- Операционная система: Windows 10/11, Linux (Ubuntu 20.04+), macOS 11+
- Docker Engine версии 20.10 или выше
- Docker Compose версии 2.0 или выше
- Python версии 3.9 или выше
- Веб-браузер: Google Chrome 90+, Mozilla Firefox 88+, Safari 14+, Microsoft Edge 90+
- Библиотеки Python: Flask 2.0+, Flask-SQLAlchemy 2.5+, psycopg2 2.9+

### 3.1.3 Установка и запуск системы

#### 3.1.3.1 Структура проекта

Система имеет следующую структуру каталогов:

```
vinlab/
├── docker-compose.yml          # Конфигурация контейнеров
├── migrations/                 # SQL-скрипты миграций
│   ├── init.sql               # Инициализация схемы БД
│   ├── admin/
│   │   ├── replica.sql        # Настройка публикации
│   │   └── insert.sql         # Тестовые данные
│   ├── shop1/
│   │   └── replica.sql        # Подписка магазина 1
│   ├── shop2/
│   │   └── replica.sql        # Подписка магазина 2
│   ├── warehouse1/
│   │   └── replica.sql        # Подписка склада 1
│   └── warehouse2/
│       └── replica.sql        # Подписка склада 2
├── app.py                      # Основное приложение Flask
├── models.py                   # Модели данных
├── templates/                  # HTML-шаблоны
│   ├── base.html
│   ├── customer_orders.html
│   └── edit_order.html
└── static/
    └── style.css              # Стили интерфейса
```

#### 3.1.3.2 Установка Docker и Docker Compose

**Для Linux (Ubuntu/Debian):**
```bash
# Обновление списка пакетов
sudo apt-get update

# Установка необходимых пакетов
sudo apt-get install -y docker.io docker-compose

# Добавление текущего пользователя в группу docker
sudo usermod -aG docker $USER

# Перезагрузка для применения изменений
newgrp docker
```

**Для Windows:**
1. Скачать Docker Desktop с https://www.docker.com/products/docker-desktop
2. Запустить установщик и следовать инструкциям
3. Перезагрузить компьютер
4. Запустить Docker Desktop

**Для macOS:**
1. Скачать Docker Desktop для Mac
2. Перетащить Docker.app в папку Applications
3. Запустить Docker из Applications

**Проверка установки:**
```bash
docker --version
docker-compose --version
```

Ожидаемый вывод:
```
Docker version 24.0.x, build xxxxx
Docker Compose version v2.x.x
```

#### 3.1.3.3 Развертывание базы данных

**Шаг 1. Подготовка SQL-скриптов**

Создать базовый скрипт инициализации `migrations/init.sql`:
```sql
-- Создание таблицы заказов
CREATE TABLE IF NOT EXISTS orders (
    id SERIAL PRIMARY KEY,
    customer_name VARCHAR(100) NOT NULL,
    customer_email VARCHAR(100) NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    total_price NUMERIC(10,2) NOT NULL CHECK (total_price >= 0),
    status VARCHAR(50) DEFAULT 'Pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Создание таблицы чеков
CREATE TABLE IF NOT EXISTS receipts (
    id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL UNIQUE REFERENCES orders(id) ON DELETE CASCADE,
    receipt_number VARCHAR(50) UNIQUE NOT NULL,
    payment_method VARCHAR(50) NOT NULL,
    payment_status VARCHAR(50) DEFAULT 'Unpaid',
    issued_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Создание индексов для оптимизации
CREATE INDEX IF NOT EXISTS idx_orders_status ON orders(status);
CREATE INDEX IF NOT EXISTS idx_orders_created_at ON orders(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_receipts_order_id ON receipts(order_id);
```

**Шаг 2. Запуск кластера баз данных**

```bash
# Переход в директорию проекта
cd vinlab

# Запуск всех контейнеров в фоновом режиме
docker-compose up -d

# Ожидаемый вывод:
# Creating network "vinlab_default" with the default driver
# Creating administration ... done
# Creating shop1         ... done
# Creating shop2         ... done
# Creating warehouse1    ... done
# Creating warehouse2    ... done
```

**Шаг 3. Проверка состояния контейнеров**

```bash
# Просмотр статуса всех контейнеров
docker-compose ps
```

Ожидаемый вывод:
```
NAME            IMAGE                  STATUS         PORTS
administration  postgres:17-alpine     Up (healthy)   0.0.0.0:5000->5432/tcp
shop1           postgres:17-alpine     Up (healthy)   0.0.0.0:5001->5432/tcp
shop2           postgres:17-alpine     Up (healthy)   0.0.0.0:5002->5432/tcp
warehouse1      postgres:17-alpine     Up (healthy)   0.0.0.0:5011->5432/tcp
warehouse2      postgres:17-alpine     Up (healthy)   0.0.0.0:5012->5432/tcp
```

**Шаг 4. Проверка инициализации баз данных**

```bash
# Подключение к центральному узлу (administration)
docker exec -it administration psql -U admin -d vinlab -c "\dt"

# Ожидаемый вывод - список таблиц:
#          List of relations
#  Schema |   Name   | Type  | Owner 
# --------+----------+-------+-------
#  public | orders   | table | admin
#  public | receipts | table | admin
```

```bash
# Проверка репликации на узле магазина
docker exec -it shop1 psql -U shop1 -d vinlab -c "\dt"

# Должны отображаться те же таблицы
```

**Шаг 5. Проверка настройки репликации**

```bash
# Проверка публикаций на центральном узле
docker exec -it administration psql -U admin -d vinlab -c "SELECT * FROM pg_publication;"

# Проверка подписок на узле магазина
docker exec -it shop1 psql -U shop1 -d vinlab -c "SELECT * FROM pg_subscription;"
```

#### 3.1.3.4 Настройка приложения Flask

**Шаг 1. Установка зависимостей Python**

```bash
# Создание виртуального окружения (рекомендуется)
python3 -m venv venv

# Активация виртуального окружения
# Для Linux/macOS:
source venv/bin/activate
# Для Windows:
venv\Scripts\activate

# Установка необходимых библиотек
pip install flask flask-sqlalchemy psycopg2-binary
```

**Шаг 2. Конфигурация подключения к БД**

Создать файл `config.py`:
```python
import os

class Config:
    # Выбор узла базы данных в зависимости от переменной окружения
    NODE = os.getenv('NODE', 'shop1')
    
    # Настройки подключения для разных узлов
    DATABASE_CONFIGS = {
        'administration': {
            'host': 'localhost',
            'port': 5000,
            'user': 'admin',
            'password': 'pass',
            'database': 'vinlab'
        },
        'shop1': {
            'host': 'localhost',
            'port': 5001,
            'user': 'shop1',
            'password': 'pass',
            'database': 'vinlab'
        },
        'shop2': {
            'host': 'localhost',
            'port': 5002,
            'user': 'shop2',
            'password': 'pass',
            'database': 'vinlab'
        },
        'warehouse1': {
            'host': 'localhost',
            'port': 5011,
            'user': 'warehouse1',
            'password': 'pass',
            'database': 'vinlab'
        },
        'warehouse2': {
            'host': 'localhost',
            'port': 5012,
            'user': 'warehouse2',
            'password': 'pass',
            'database': 'vinlab'
        }
    }
    
    # Формирование строки подключения
    db_config = DATABASE_CONFIGS[NODE]
    SQLALCHEMY_DATABASE_URI = (
        f"postgresql://{db_config['user']}:{db_config['password']}"
        f"@{db_config['host']}:{db_config['port']}/{db_config['database']}"
    )
    
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    SECRET_KEY = 'your-secret-key-here-change-in-production'
```

Обновить `app.py`:
```python
from flask import Flask
from models import db
from config import Config

app = Flask(__name__)
app.config.from_object(Config)
db.init_app(app)

# ... остальной код приложения
```

**Шаг 3. Запуск приложения**

```bash
# Запуск для магазина 1
export NODE=shop1
python app.py

# Приложение запустится на http://127.0.0.1:8001
```

Для одновременного запуска нескольких узлов использовать разные порты:

```bash
# Терминал 1 - Магазин 1
export NODE=shop1
export FLASK_PORT=8001
flask run --port 8001

# Терминал 2 - Магазин 2
export NODE=shop2
export FLASK_PORT=8002
flask run --port 8002
```

#### 3.1.3.5 Управление контейнерами

**Просмотр логов контейнера:**
```bash
# Логи конкретного узла
docker-compose logs administration
docker-compose logs shop1

# Последние 100 строк с отслеживанием
docker-compose logs -f --tail=100 shop1
```

**Остановка системы:**
```bash
# Остановка всех контейнеров
docker-compose stop

# Остановка и удаление контейнеров (данные сохраняются)
docker-compose down

# Полное удаление включая volumes (ОСТОРОЖНО: удаляет все данные)
docker-compose down -v
```

**Перезапуск отдельного узла:**
```bash
# Перезапуск магазина 1
docker-compose restart shop1
```

**Проверка состояния репликации:**
```bash
# Задержка репликации на реплике
docker exec -it shop1 psql -U shop1 -d vinlab -c \
  "SELECT NOW() - pg_last_xact_replay_timestamp() AS replication_lag;"
```

#### 3.1.3.6 Устранение типичных проблем

**Проблема: Контейнер не запускается**
```bash
# Проверка логов для диагностики
docker-compose logs administration

# Принудительное пересоздание контейнера
docker-compose up -d --force-recreate administration
```

**Проблема: Порт уже занят**
```bash
# Проверка занятых портов
sudo netstat -tulpn | grep 5432

# Изменение портов в docker-compose.yml
# Например: "5100:5432" вместо "5000:5432"
```

**Проблема: Ошибка подключения к БД из приложения**
```bash
# Проверка доступности порта
telnet localhost 5001

# Проверка credentials
docker exec -it shop1 psql -U shop1 -d vinlab -c "SELECT version();"
```

### 3.1.4 Интерфейс клиента магазина

Доступен по адресу: `http://localhost:8001/customer` (для shop1)

**Функциональные возможности:**
- Просмотр списка заказов с информацией о товарах, количестве, стоимости, статусе и чеках
- Детальный просмотр информации о конкретном заказе
- Редактирование заказов в статусе "Pending" (Ожидает обработки)
- Отмена заказов в статусах "Pending" и "Processing"

**Последовательность действий для просмотра заказов:**
1. Открыть в браузере адрес `http://localhost:8001/customer`
2. На экране отобразится таблица со всеми заказами текущего магазина
3. Для каждого заказа доступна следующая информация:
   - Номер заказа
   - Наименование товара
   - Количество единиц
   - Общая стоимость в рублях
   - Текущий статус заказа
   - Дата создания
   - Информация о чеке (номер, способ и статус оплаты)

**Последовательность действий для редактирования заказа:**
1. На странице "Мои заказы" найти заказ в статусе "Pending"
2. Нажать кнопку "Изменить" в строке заказа
3. В открывшейся форме внести необходимые изменения в доступные поля:
   - Имя клиента (название магазина)
   - Email клиента
   - Наименование товара
   - Количество (целое положительное число)
   - Общая сумма (число с двумя знаками после запятой)
4. Нажать кнопку "Сохранить изменения"
5. Система отобразит уведомление об успешном обновлении и вернет на список заказов
6. Изменения автоматически реплицируются на центральный узел (administration)

**Последовательность действий для отмены заказа:**
1. На странице "Мои заказы" найти заказ в статусе "Pending" или "Processing"
2. Нажать кнопку "Отменить" в строке заказа
3. Подтвердить действие во всплывающем диалоговом окне
4. Статус заказа изменится на "Cancelled", статус оплаты чека автоматически изменится на "Refunded"
5. Система отобразит уведомление об отмене заказа
6. Изменение статуса реплицируется на все узлы системы

### 3.1.5 Справочная информация о статусах

**Статусы заказов:**
- **Pending** (Ожидает обработки) — начальный статус, заказ принят системой
- **Processing** (В обработке) — заказ находится в процессе комплектации
- **Shipped** (Отправлен) — заказ отправлен в магазин
- **Delivered** (Доставлен) — заказ получен магазином
- **Cancelled** (Отменен) — заказ отменен

**Статусы оплаты:**
- **Unpaid** (Не оплачен) — платеж не произведен
- **Paid** (Оплачен) — платеж успешно завершен
- **Refunded** (Возврат) — произведен возврат средств

---

## 3.2 Модули (компоненты) системы

### 3.2.1 Архитектура системы

Система "Винлаб" реализована по архитектурному шаблону MVC (Model-View-Controller):

```
┌─────────────────────────────────────────┐
│        Презентационный уровень          │
│  (HTML-шаблоны, CSS, веб-браузер)      │
└───────────────┬─────────────────────────┘
                │ HTTP-запросы/ответы
┌───────────────▼─────────────────────────┐
│         Уровень приложения              │
│     (Flask, маршруты, контроллеры)     │
└───────────────┬─────────────────────────┘
                │ ORM (SQLAlchemy)
┌───────────────▼─────────────────────────┐
│          Уровень данных                 │
│         (PostgreSQL кластер)            │
│  ┌─────────────────────────────────┐   │
│  │     Administration (Master)     │   │
│  │         Port 5000               │   │
│  └──┬────────────┬────────────┬────┘   │
│     │            │            │         │
│  ┌──▼──┐     ┌──▼──┐     ┌──▼──┐      │
│  │Shop1│     │Shop2│     │WH1/2│      │
│  │5001 │     │5002 │     │5011 │      │
│  └─────┘     └─────┘     └─────┘      │
│    (Логическая репликация)             │
└─────────────────────────────────────────┘
```

### 3.2.2 Модуль моделей данных (models.py)

**Назначение:** определение структуры данных и связей между сущностями предметной области.

#### 3.2.2.1 Класс Order

Представляет заказ на поставку товара в магазин.

**Атрибуты:**
- `id` (Integer, PRIMARY KEY) — уникальный идентификатор заказа
- `customer_name` (String(100), NOT NULL) — наименование магазина-получателя
- `customer_email` (String(100), NOT NULL) — контактный email магазина
- `product_name` (String(200), NOT NULL) — наименование алкогольного товара
- `quantity` (Integer, NOT NULL) — количество единиц товара
- `total_price` (Float, NOT NULL) — общая стоимость заказа в рублях
- `status` (String(50), DEFAULT 'Pending') — текущий статус заказа
- `created_at` (DateTime, DEFAULT CURRENT_TIMESTAMP) — дата и время создания записи
- `updated_at` (DateTime, DEFAULT CURRENT_TIMESTAMP) — дата и время последнего обновления

**Связи:**
- Один-к-одному с таблицей `receipts` через атрибут `receipt`
- Каскадное удаление: при удалении заказа автоматически удаляется связанный чек

#### 3.2.2.2 Класс Receipt

Представляет товарно-транспортную накладную и платежный документ.

**Атрибуты:**
- `id` (Integer, PRIMARY KEY) — уникальный идентификатор чека
- `order_id` (Integer, FOREIGN KEY → orders.id, UNIQUE, NOT NULL) — внешний ключ на заказ
- `receipt_number` (String(50), UNIQUE, NOT NULL) — уникальный номер накладной
- `payment_method` (String(50), NOT NULL) — способ оплаты (Card, Cash, PayPal)
- `payment_status` (String(50), DEFAULT 'Unpaid') — статус оплаты
- `issued_at` (DateTime, DEFAULT CURRENT_TIMESTAMP) — дата и время выдачи накладной

**Связи:**
- Многие-к-одному с таблицей `orders` через внешний ключ `order_id`

### 3.2.3 Модуль приложения (app.py)

**Назначение:** реализация бизнес-логики, обработка HTTP-запросов, маршрутизация.

#### 3.2.3.1 Конфигурация приложения

```python
app.config.from_object(Config)
# Динамическое определение строки подключения на основе NODE
```

#### 3.2.3.2 Вспомогательные функции

**generate_receipt_number()**
- Назначение: генерация уникального идентификатора накладной
- Алгоритм: префикс "RCP-" + 10 случайных символов (заглавные буквы и цифры)
- Возвращает: строку формата "RCP-A1B2C3D4E5"

#### 3.2.3.3 Маршруты клиентского интерфейса

**GET /customer** — отображение списка заказов магазина
- Извлекает все заказы из локальной БД узла
- Сортирует по дате создания (от новых к старым)
- Передает данные в шаблон customer_orders.html

**GET /customer/order/<id>** — просмотр детальной информации о заказе
- Извлекает заказ по идентификатору
- Возвращает ошибку 404, если заказ не найден
- Отображает форму в режиме только для чтения

**GET /customer/order/<id>/edit** — форма редактирования заказа
- Проверяет статус заказа (должен быть 'Pending')
- При несоответствии статуса выводит предупреждение и перенаправляет на список
- Отображает форму с возможностью редактирования

**POST /customer/order/<id>/edit** — сохранение изменений заказа
- Проверяет статус заказа
- Обновляет поля: customer_name, customer_email, product_name, quantity, total_price
- Устанавливает updated_at в текущее время
- Фиксирует изменения в БД (автоматически реплицируются через PostgreSQL)
- Перенаправляет на список заказов с сообщением об успехе

**POST /customer/order/<id>/cancel** — отмена заказа
- Проверяет возможность отмены (статус Pending или Processing)
- Устанавливает status = 'Cancelled'
- Устанавливает receipt.payment_status = 'Refunded' (если чек существует)
- Фиксирует изменения и перенаправляет на список

### 3.2.4 Модуль представлений (templates/)

**base.html** — базовый шаблон
- Определяет общую структуру HTML-страницы
- Содержит навигационную панель
- Предоставляет блоки для переопределения в дочерних шаблонах
- Отображает flash-сообщения

**customer_orders.html** — список заказов
- Наследуется от base.html
- Отображает таблицу со всеми заказами
- Условно показывает кнопки действий в зависимости от статуса
- Использует цикл Jinja2 для вывода строк таблицы

**edit_order.html** — форма работы с заказом
- Универсальная форма для просмотра/редактирования
- Адаптируется в зависимости от параметров (editable, user_type)
- Содержит секции: информация о клиенте, информация о заказе
- Реализует валидацию на стороне клиента (HTML5)

### 3.2.5 Модуль стилей (static/style.css)

**Назначение:** визуальное оформление интерфейса.

**Основные компоненты:**
- Сброс стилей и базовые правила для нормализации отображения
- Система кнопок с различными состояниями (primary, danger, success)
- Стили таблиц с чередованием строк
- Цветовые бейджи для статусов заказов и платежей
- Адаптивная верстка для мобильных устройств (медиа-запрос ≤768px)

### 3.2.6 Модуль базы данных

**СУБД:** PostgreSQL 17 (Alpine Linux edition)

**Архитектура кластера:**
- 5 узлов в Docker-контейнерах
- Один центральный узел (administration) на порту 5000
- Два узла магазинов (shop1, shop2) на портах 5001, 5002
- Два узла складов (warehouse1, warehouse2) на портах 5011, 5012

**Конфигурация PostgreSQL для репликации:**
```
wal_level=logical           # Уровень WAL для логической репликации
max_replication_slots=10    # Максимум слотов репликации
max_wal_senders=10         # Максимум процессов отправки WAL
listen_addresses='*'        # Прослушивание на всех интерфейсах
```

**Таблицы:**

```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    customer_name VARCHAR(100) NOT NULL,
    customer_email VARCHAR(100) NOT NULL,
    product_name VARCHAR(200) NOT NULL,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    total_price NUMERIC(10,2) NOT NULL CHECK (total_price >= 0),
    status VARCHAR(50) DEFAULT 'Pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE receipts (
    id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL UNIQUE REFERENCES orders(id) ON DELETE CASCADE,
    receipt_number VARCHAR(50) UNIQUE NOT NULL,
    payment_method VARCHAR(50) NOT NULL,
    payment_status VARCHAR(50) DEFAULT 'Unpaid',
    issued_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Индексы:**
- PRIMARY KEY на orders.id и receipts.id
- UNIQUE на receipts.order_id (обеспечивает связь один-к-одному)
- UNIQUE на receipts.receipt_number
- INDEX на orders.status для оптимизации фильтрации
- INDEX на orders.created_at для сортировки

**Ограничения целостности:**
- NOT NULL на обязательные поля
- FOREIGN KEY с каскадным удалением (ON DELETE CASCADE)
- CHECK-ограничения на quantity > 0 и total_price >= 0

---

## 3.3 Реализация репликации

### 3.3.1 Концепция распределенной архитектуры

Система "Винлаб" функционирует в распределенной среде с географически разнесенными узлами. Каждый магазин и склад имеет собственную реплику базы данных для обеспечения:
- Автономности работы при проблемах с сетью
- Снижения задержек при локальных операциях чтения
- Балансировки нагрузки между узлами
- Отказоустойчивости системы в целом

Репликация данных реализуется встроенными средствами PostgreSQL (логическая репликация) без необходимости разработки дополнительного кода на уровне приложения.

### 3.3.2 Топология репликации

Система использует топологию "звезда" с центральным координирующим узлом:

```
           ┌────────────────────┐
           │  Administration    │
           │  (Центральный узел)│
           │  Port 5000         │
           └─────────┬──────────┘
                     │
         ┌───────────┼───────────┬───────────┐
         │           │           │           │
    ┌────▼────┐ ┌───▼────┐ ┌───▼────┐ ┌───▼────┐
    │ Shop 1  │ │ Shop 2 │ │Wareh.1 │ │Wareh.2 │
    │Port 5001│ │Port5002│ │Port5011│ │Port5012│
    └─────────┘ └────────┘ └────────┘ └────────┘
```

**Характеристики репликации:**
- **Тип:** Логическая репликация PostgreSQL (Logical Replication)
- **Направление:** Двунаправленная (bidirectional)
  - От administration к магазинам/складам — новые заказы, изменения
  - От магазинов/складов к administration — обновления статусов, отмены
- **Режим:** Асинхронная репликация
- **Гранулярность:** На уровне таблиц (orders, receipts)

### 3.3.3 Механизм логической репликации PostgreSQL

PostgreSQL использует архитектуру "издатель-подписчик" (publisher-subscriber):

**Издатель (Publisher)** — узел administration:
- Создает публикацию (publication) для таблиц orders и receipts
- Отслеживает изменения через WAL (Write-Ahead Log)
- Передает изменения всем подписчикам

**Подписчики (Subscribers)** — узлы магазинов и складов:
- Создают подписки (subscriptions) на публикацию центрального узла
- Получают и применяют изменения локально
- Могут сами выступать издателями для обратной репликации

**SQL-скрипты конфигурации:**

На узле **administration** (файл `migrations/admin/replica.sql`):
```sql
-- Создание публикации для репликации
CREATE PUBLICATION vinlab_publication 
FOR TABLE orders, receipts
WITH (publish = 'insert, update, delete');

-- Предоставление прав доступа для репликации
GRANT SELECT ON orders, receipts TO shop1, shop2, warehouse1, warehouse2;
```

На узле **shop1** (файл `migrations/shop1/replica.sql`):
```sql
-- Создание подписки на центральный узел
CREATE SUBSCRIPTION shop1_subscription
CONNECTION 'host=administration port=5432 dbname=vinlab user=admin password=pass'
PUBLICATION vinlab_publication
WITH (
    copy_data = true,           -- Копировать существующие данные
    create_slot = true,         -- Создать слот репликации
    enabled = true,             -- Активировать немедленно
    synchronous_commit = off    -- Асинхронный режим
);
```

Аналогичные скрипты создаются для остальных узлов (shop2, warehouse1, warehouse2).

### 3.3.4 Процесс синхронизации данных

**Последовательность репликации изменений:**

1. **Фиксация транзакции на узле-источнике:**
   - Приложение выполняет INSERT/UPDATE/DELETE
   - PostgreSQL сохраняет изменения в WAL
   - Транзакция подтверждается (COMMIT)

2. **Декодирование изменений:**
   - Процесс логической репликации декодирует записи WAL
   - Формируются логические сообщения об изменениях

3. **Передача по сети:**
   - Изменения отправляются подписчикам через TCP-соединение
   - Используется бинарный протокол репликации PostgreSQL

4. **Применение на узле-получателе:**
   - Подписчик получает изменения
   - Применяет их к локальным таблицам
   - Обновляет позицию в потоке репликации (LSN)

**Типичное время задержки репликации:**
- В локальной сети: < 100 мс
- Через интернет: 200-500 мс (зависит от расстояния и качества канала)

### 3.3.5 Обработка конфликтов

При логической репликации PostgreSQL возможны конфликты, когда одна и та же запись изменяется на разных узлах. 

**Встроенные механизмы разрешения:**

1. **Конфликт UPDATE/UPDATE** (одна запись изменена на двух узлах):
   - PostgreSQL использует стратегию "последняя запись побеждает"
   - Применяется изменение с более поздним системным временем (LSN)

2. **Конфликт INSERT** (попытка вставить запись с существующим PRIMARY KEY):
   - Репликация останавливается с ошибкой
   - Требуется ручное вмешательство администратора

3. **Конфликт DELETE** (попытка удалить несуществующую запись):
   - Операция игнорируется, репликация продолжается

**Минимизация конфликтов в системе "Винлаб":**

- Заказы создаются только на центральном узле (administration)
- Магазины могут изменять только ограниченный набор полей (customer_*, quantity, total_price)
- Статусы заказов изменяются последовательно и однонаправленно
- Используется поле `updated_at` для определения актуальности данных

### 3.3.6 Мониторинг репликации

**Проверка состояния репликации на издателе (administration):**

```sql
-- Список активных подписчиков
SELECT * FROM pg_stat_replication;

-- Информация о слотах репликации
SELECT slot_name, active, restart_lsn 
FROM pg_replication_slots;
```

**Проверка на подписчике (shop1):**

```sql
-- Статус подписки
SELECT subname, subenabled, subslotname 
FROM pg_subscription;

-- Задержка репликации
SELECT NOW() - pg_last_xact_replay_timestamp() AS replication_lag;
```

**Критические показатели:**
- `replication_lag` не должна превышать 10 секунд при нормальной работе
- `active = true` в pg_stat_replication означает активное соединение
- `restart_lsn` не должен долго оставаться на одном значении

**Команды для мониторинга через Docker:**

```bash
# Задержка репликации на shop1
docker exec -it shop1 psql -U shop1 -d vinlab -c \
  "SELECT NOW() - pg_last_xact_replay_timestamp();"

# Статус репликации на administration
docker exec -it administration psql -U admin -d vinlab -c \
  "SELECT client_addr, state, sync_state FROM pg_stat_replication;"
```

### 3.3.7 Восстановление после сбоев

**Сценарий 1: Кратковременная потеря связи**
- PostgreSQL автоматически восстанавливает соединение
- Накопленные изменения передаются после восстановления связи
- Не требуется вмешательство администратора

**Сценарий 2: Длительный разрыв соединения**
- Изменения накапливаются в WAL на издателе
- При превышении `max_wal_size` старые сегменты могут быть удалены
- После восстановления связи может потребоваться повторная синхронизация

**Команда для повторной синхронизации:**
```sql
-- На подписчике
ALTER SUBSCRIPTION shop1_subscription REFRESH PUBLICATION;
```

---

## 3.4 Методика испытаний

### 3.4.1 Цели и задачи испытаний

**Цель:** проверка корректности работы клиентского интерфейса системы "Винлаб" в узлах-магазинах.

**Задачи:**
1. Функциональное тестирование операций с заказами
2. Проверка бизнес-логики ограничений доступа
3. Валидационное тестирование ввода данных
4. Тестирование интеграции с базой данных

### 3.4.2 Подготовка тестовой среды

**Конфигурация тестового окружения:**
- ОС: Ubuntu 20.04 LTS
- Docker: версия 24.0.7
- Docker Compose: версия 2.23.0
- PostgreSQL: версия 17 (Alpine)
- Python: версия 3.9.7
- Flask: версия 2.0.3

**Развертывание:**

```bash
# 1. Клонирование репозитория
git clone https://github.com/example/vinlab.git
cd vinlab

# 2. Запуск кластера БД
docker-compose up -d

# 3. Ожидание готовности всех узлов
docker-compose ps
# Все контейнеры должны иметь статус "Up (healthy)"

# 4. Настройка Python-окружения
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt

# 5. Запуск приложения для магазина 1
export NODE=shop1
python app.py
```

**Тестовые данные (создаются автоматически):**
- 3 заказа в статусе Pending
- 2 заказа в статусе Processing
- 1 заказ в статусе Delivered
- 1 заказ в статусе Cancelled

### 3.4.3 Функциональное тестирование

#### Тест-кейс FT-01: Просмотр списка заказов

| Параметр | Значение |
|----------|----------|
| ID | FT-01 |
| Название | Отображение списка заказов магазина |
| Предусловия | БД содержит 7 тестовых заказов |
| Шаги | 1. Открыть http://localhost:8001/customer<br>2. Проверить наличие таблицы заказов |
| Ожидаемый результат | - Отображается таблица с 8 колонками<br>- Все 7 заказов присутствуют<br>- Данные соответствуют записям в БД |
| Метод проверки | Визуальный осмотр, сравнение с SQL-запросом:<br>`docker exec -it shop1 psql -U shop1 -d vinlab -c "SELECT * FROM orders ORDER BY created_at DESC"` |
| Критерий успеха | Все заказы отображены корректно |

#### Тест-кейс FT-02: Редактирование заказа Pending

| Параметр | Значение |
|----------|----------|
| ID | FT-02 |
| Название | Изменение данных заказа клиентом |
| Предусловия | Заказ #1 имеет статус Pending |
| Входные данные | quantity: 10 → 15<br>total_price: 5000 → 7500 |
| Шаги | 1. На /customer найти заказ #1<br>2. Нажать "Изменить"<br>3. Изменить quantity на 15<br>4. Изменить total_price на 7500<br>5. Нажать "Сохранить" |
| Ожидаемый результат | - Сообщение "Заказ успешно обновлен!"<br>- Редирект на /customer<br>- В таблице отображены новые значения<br>- updated_at обновлен в БД |
| Метод проверки | SQL-запрос:<br>`docker exec -it shop1 psql -U shop1 -d vinlab -c "SELECT quantity, total_price, updated_at FROM orders WHERE id=1"` |
| Критерий успеха | Изменения сохранены |

#### Тест-кейс FT-03: Запрет редактирования Processing

| Параметр | Значение |
|----------|----------|
| ID | FT-03 |
| Название | Блокировка редактирования обрабатываемого заказа |
| Предусловия | Заказ #2 имеет статус Processing |
| Шаги | 1. На /customer найти заказ #2<br>2. Проверить наличие кнопки "Изменить" |
| Ожидаемый результат | Кнопка "Изменить" отсутствует<br>Доступна только кнопка "Просмотр" |
| Метод проверки | Инспектирование HTML-кода страницы (F12 в браузере) |
| Критерий успеха | Редактирование недоступно |

#### Тест-кейс FT-04: Отмена заказа Pending

| Параметр | Значение |
|----------|----------|
| ID | FT-04 |
| Название | Отмена заказа в начальном статусе |
| Предусловия | Заказ #3 в статусе Pending с чеком |
| Шаги | 1. Найти заказ #3<br>2. Нажать "Отменить"<br>3. Подтвердить в диалоге |
| Ожидаемый результат | - order.status = 'Cancelled'<br>- receipt.payment_status = 'Refunded'<br>- Сообщение "Заказ отменен" |
| Метод проверки | SQL:<br>`docker exec -it shop1 psql -U shop1 -d vinlab -c "SELECT o.status, r.payment_status FROM orders o JOIN receipts r ON o.id=r.order_id WHERE o.id=3"` |
| Критерий успеха | Статусы изменены |

#### Тест-кейс FT-05: Отмена заказа Processing

| Параметр | Значение |
|----------|----------|
| ID | FT-05 |
| Название | Отмена заказа в обработке |
| Предусловия | Заказ #4 в статусе Processing |
| Шаги | 1. Найти заказ #4<br>2. Нажать "Отменить"<br>3. Подтвердить |
| Ожидаемый результат | Аналогично FT-04 |
| Критерий успеха | Отмена выполнена |

#### Тест-кейс FT-06: Запрет отмены Delivered

| Параметр | Значение |
|----------|----------|
| ID | FT-06 |
| Название | Блокировка отмены доставленного заказа |
| Предусловия | Заказ #5 в статусе Delivered |
| Шаги | 1. Найти заказ #5<br>2. Проверить наличие кнопки "Отменить" |
| Ожидаемый результат | Кнопка "Отменить" отсутствует |
| Критерий успеха | Отмена недоступна |

### 3.4.4 Валидационное тестирование

#### Тест-кейс VT-01: Валидация количества

| Параметр | Значение |
|----------|----------|
| ID | VT-01 |
| Название | Проверка ограничений поля quantity |
| Шаги | 1. Редактировать Pending заказ<br>2. Ввести quantity = -5<br>3. Попытаться сохранить |
| Ожидаемый результат | HTML5 валидация блокирует отправку<br>Сообщение "Значение должно быть больше или равно 1" |
| Критерий успеха | Невалидные данные отклонены |

#### Тест-кейс VT-02: Валидация email

| Параметр | Значение |
|----------|----------|
| ID | VT-02 |
| Название | Проверка формата email |
| Шаги | 1. Редактировать заказ<br>2. Ввести customer_email = "invalid"<br>3. Сохранить |
| Ожидаемый результат | Браузер показывает ошибку формата email |
| Критерий успеха | Некорректный email отклонен |

#### Тест-кейс VT-03: Обязательные поля

| Параметр | Значение |
|----------|----------|
| ID | VT-03 |
| Название | Проверка заполнения обязательных полей |
| Шаги | 1. Редактировать заказ<br>2. Очистить поле product_name<br>3. Сохранить |
| Ожидаемый результат | Сообщение "Заполните это поле" |
| Критерий успеха | Пустое поле блокирует отправку |

### 3.4.5 Тестирование интеграции с БД

#### Тест-кейс IT-01: Транзакционность операций

| Параметр | Значение |
|----------|----------|
| ID | IT-01 |
| Название | Целостность при ошибке БД |
| Шаги | 1. Остановить контейнер shop1: `docker-compose stop shop1`<br>2. Попытаться открыть /customer<br>3. Запустить контейнер: `docker-compose start shop1`<br>4. Проверить состояние данных |
| Ожидаемый результат | - Отображается ошибка подключения<br>- После восстановления данные не повреждены<br>- Частичные изменения отсутствуют |
| Критерий успеха | Данные целостны |

#### Тест-кейс IT-02: Каскадное удаление

| Параметр | Значение |
|----------|----------|
| ID | IT-02 |
| Название | Удаление связанных записей |
| Предусловия | Заказ #7 имеет связанный чек |
| Шаги | 1. Выполнить SQL:<br>`docker exec -it shop1 psql -U shop1 -d vinlab -c "DELETE FROM orders WHERE id=7"`<br>2. Проверить наличие чека |
| Ожидаемый результат | Запись из receipts также удалена |
| Метод проверки | SQL:<br>`docker exec -it shop1 psql -U shop1 -d vinlab -c "SELECT COUNT(*) FROM receipts WHERE order_id=7"` → 0 |
| Критерий успеха | Каскадное удаление работает |

### 3.4.6 Регистрация результатов тестирования

**Форма протокола испытаний:**

```
═══════════════════════════════════════════════════════════════════
  ПРОТОКОЛ ФУНКЦИОНАЛЬНЫХ ИСПЫТАНИЙ № 001
═══════════════════════════════════════════════════════════════════

Система: Винлаб (клиентский модуль магазина)
Версия: 1.0.0
Дата проведения: ___________
Ответственный тестировщик: ___________
Окружение: 
  - Docker 24.0.7, PostgreSQL 17-alpine
  - Python 3.9.7, Flask 2.0.3
  - Узел: shop1 (port 5001)

───────────────────────────────────────────────────────────────────
РЕЗУЛЬТАТЫ ТЕСТИРОВАНИЯ:
───────────────────────────────────────────────────────────────────

┌────────┬─────────────────────────────────────┬──────────┬───────────┐
│ Тест-ID│ Наименование                        │ Результат│ Примечание│
├────────┼─────────────────────────────────────┼──────────┼───────────┤
│ FT-01  │ Просмотр списка заказов            │ ☐ Pass   │           │
│        │                                     │ ☐ Fail   │           │
├────────┼─────────────────────────────────────┼──────────┼───────────┤
│ FT-02  │ Редактирование заказа Pending      │ ☐ Pass   │           │
│        │                                     │ ☐ Fail   │           │
├────────┼─────────────────────────────────────┼──────────┼───────────┤
│ FT-03  │ Запрет редактирования Processing   │ ☐ Pass   │           │
│        │                                     │ ☐ Fail   │           │
├────────┼─────────────────────────────────────┼──────────┼───────────┤
│ FT-04  │ Отмена заказа Pending              │ ☐ Pass   │           │
│        │                                     │ ☐ Fail   │           │
├────────┼─────────────────────────────────────┼──────────┼───────────┤
│ FT-05  │ Отмена заказа Processing           │ ☐ Pass   │           │
│        │                                     │ ☐ Fail   │           │
├────────┼─────────────────────────────────────┼──────────┼───────────┤
│ FT-06  │ Запрет отмены Delivered            │ ☐ Pass   │           │
│        │                                     │ ☐ Fail   │           │
├────────┼─────────────────────────────────────┼──────────┼───────────┤
│ VT-01  │ Валидация количества               │ ☐ Pass   │           │
│        │                                     │ ☐ Fail   │           │
├────────┼─────────────────────────────────────┼──────────┼───────────┤
│ VT-02  │ Валидация email                    │ ☐ Pass   │           │
│        │                                     │ ☐ Fail   │           │
├────────┼─────────────────────────────────────┼──────────┼───────────┤
│ VT-03  │ Обязательные поля                  │ ☐ Pass   │           │
│        │                                     │ ☐ Fail   │           │
├────────┼─────────────────────────────────────┼──────────┼───────────┤
│ IT-01  │ Транзакционность операций          │ ☐ Pass   │           │
│        │                                     │ ☐ Fail   │           │
├────────┼─────────────────────────────────────┼──────────┼───────────┤
│ IT-02  │ Каскадное удаление                 │ ☐ Pass   │           │
│        │                                     │ ☐ Fail   │           │
└────────┴─────────────────────────────────────┴──────────┴───────────┘

───────────────────────────────────────────────────────────────────
СТАТИСТИКА:
───────────────────────────────────────────────────────────────────
Всего тест-кейсов:       11
Выполнено успешно:       ___
Провалено:               ___
Заблокировано:           ___
Процент успеха:          ___%

───────────────────────────────────────────────────────────────────
ВЫЯВЛЕННЫЕ ДЕФЕКТЫ:
───────────────────────────────────────────────────────────────────
1. [ID] [Описание] [Критичность: Высокая/Средняя/Низкая]
2. ...

───────────────────────────────────────────────────────────────────
ЗАКЛЮЧЕНИЕ:
───────────────────────────────────────────────────────────────────
☐ Система соответствует требованиям и готова к эксплуатации
☐ Требуются исправления критичных дефектов
☐ Требуется повторное тестирование

Комментарии:
_________________________________________________________________
_________________________________________________________________

Подпись тестировщика: ___________ Дата: ___________

Подпись руководителя проекта: ___________ Дата: ___________

═══════════════════════════════════════════════════════════════════
```

---

**КОНЕЦ ДОКУМЕНТА**